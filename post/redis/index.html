<html>
  <head>
    <meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Redis | myStudyNotes</title>
<link rel="shortcut icon" href="https://rexshi96.github.io/favicon.ico?v=1594441221030">
<link href="https://cdn.jsdelivr.net/npm/remixicon@2.3.0/fonts/remixicon.css" rel="stylesheet">
<link rel="stylesheet" href="https://rexshi96.github.io/styles/main.css">
<link rel="alternate" type="application/atom+xml" title="Redis | myStudyNotes - Atom Feed" href="https://rexshi96.github.io/atom.xml">
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Droid+Serif:400,700">



    <meta name="description" content="Redis
1.简介
概念：Redis (REmote DIctionary Server) 是用 C 语言开发的一个开源的高性能键值对（key-value）数据库。
特征：
1.  数据间没有必然的关联关系
2. 内部采用单线程机制进行工..." />
    <meta name="keywords" content="JAVAWEB" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
    <script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>
  </head>
  <body>
    <div class="main">
      <div class="main-content">
        <div class="site-header">
  <a href="https://rexshi96.github.io">
  <img class="avatar" src="https://rexshi96.github.io/images/avatar.png?v=1594441221030" alt="">
  </a>
  <h1 class="site-title">
    myStudyNotes
  </h1>
  <p class="site-description">
    
  </p>
  <div class="menu-container">
    
      
        <a href="archives" class="menu">
          学习笔记
        </a>
      
    
  </div>
  <div class="social-container">
    
      
    
      
    
      
    
      
    
      
    
  </div>
</div>

        <div class="post-detail">
          <article class="post">
            <h2 class="post-title">
              Redis
            </h2>
            <div class="post-info">
              <span>
                2020-07-11
              </span>
              <span>
                11 min read
              </span>
              
                <a href="https://rexshi96.github.io/tag/KLZKNXLMc/" class="post-tag">
                  # JAVAWEB
                </a>
              
            </div>
            
            <div class="post-content-wrapper">
              <div class="post-content">
                <h1 id="redis">Redis</h1>
<h2 id="1简介">1.简介</h2>
<p>概念：Redis (REmote DIctionary Server) 是用 C 语言开发的一个开源的高性能键值对（key-value）数据库。</p>
<p>特征：</p>
<pre><code class="language-java">1.  数据间没有必然的关联关系
2. 内部采用单线程机制进行工作
3. 高性能。官方提供测试数据，50个并发执行100000 个请求,读的速度是110000 次/s,写的速度是81000次/s。
4. 多数据类型支持
   * 字符串类型 string
   * 列表类型 list
   * 散列类型 hash
   * 集合类型 set
   * 有序集合类型 sorted_set
5. 持久化支持。可以进行数据灾难恢复
</code></pre>
<p>应用：</p>
<pre><code class="language-java">1. 为热点数据加速查询（主要场景），如热点商品、热点新闻、热点资讯、推广类等高访问量信息等
2. 任务队列，如秒杀、抢购、购票排队等
3.  即时信息查询，如各位排行榜、各类网站访问统计、公交到站信息、在线人数信息（聊天室、网站）、设
   备信号等
4.  时效性信息控制，如验证码控制、投票控制等
5.  分布式数据共享，如分布式集群架构中的 session 分离
6.  消息队列
7. 分布式锁
</code></pre>
<h2 id="2数据类型">2.数据类型</h2>
<p>Redis 数据类型（5种常用）</p>
<pre><code class="language-java">* string		   String
* hash             HashMap
* list             LinkedList
* set              HashSet
* sorted_set       TreeSet
</code></pre>
<p>redis 数据存储格式:</p>
<pre><code class="language-java">redis 自身是一个 Map，其中所有的数据都是采用 key : value 的形式存储
数据类型指的是存储的数据的类型，也就是 value 部分的类型，key 部分永远都是字符串
</code></pre>
<h3 id="string类型">string类型</h3>
<pre><code class="language-java"> 存储的数据：单个数据，最简单的数据存储类型，也是最常用的数据存储类型
 存储数据的格式：一个存储空间保存一个数据
 存储内容：通常使用字符串，如果字符串以整数的形式展示，可以作为数字操作使用 Tips 1：
	* redis用于控制数据库表主键id，为数据库表主键提供生成策略，保障数据库表的主键唯一性
	* 此方案适用于所有数据库，且支持数据库集群
    
Tips 2：
    * redis 控制数据的生命周期，通过数据是否失效控制业务行为，适用于所有具有时效性限定控制的操作

Tips 3：
    * redis应用于各种结构型和非结构型高热度数据访问加速


</code></pre>
<pre><code class="language-java">key 的设置约定 ：
    数据库中的热点数据key命名惯例
    表名：主键名：主键值：字段名
</code></pre>
<h3 id="hash类型">hash类型</h3>
<pre><code class="language-java">hash存储结构优化
    如果field数量较少，存储结构优化为类数组结构
    如果field数量较多，存储结构使用HashMap结构

hash 类型数据操作的注意事项：
    hash类型下的value只能存储字符串，不允许存储其他数据类型，不存在嵌套现象。如果数据未获取到，对应的值为（nil）
    每个 hash 可以存储 2 32 - 1 个键值对
    hash类型十分贴近对象的数据存储形式，并且可以灵活添加删除对象属性。但hash设计初衷不是为了存储大量对象而设计的，切记不可滥用，更不可以将hash作为对象列表使用
    hgetall 操作可以获取全部属性，如果内部field过多，遍历整体数据效率就很会低，有可能成为数据访问瓶颈
    
Tips 4：
    redis 应用于购物车数据存储设计
Tips 5：
    redis 应用于抢购，限购类、限量发放优惠卷、激活码等业务的数据存储设计
</code></pre>
<h3 id="list类型">list类型</h3>
<ul>
<li>数据存储需求：存储多个数据，并对数据进入存储空间的顺序进行区分</li>
<li>需要的存储结构：一个存储空间保存多个数据，且通过数据可以体现进入顺序</li>
<li>list类型：保存多个数据，底层使用双向链表存储结构实现</li>
</ul>
<figure data-type="image" tabindex="1"><img src="https://rexshi96.github.io/post-images/1594434421776.png" alt="" loading="lazy"></figure>
<p>Tips 6：</p>
<p>​			redis 应用于具有操作先后顺序的数据控制</p>
<p>Tips 7：<br>
redis 应用于最新消息展示</p>
<pre><code class="language-java">list 类型数据操作注意事项：

* list中保存的数据都是string类型的，数据总容量是有限的，最多2 32 - 1 个元素 (4294967295)。
*  list具有索引的概念，但是操作数据时通常以队列的形式进行入队出队操作，或以栈的形式进行入栈出栈操作 
* 获取全部数据操作结束索引设置为-1
* list可以对数据进行分页操作，通常第一页的信息来自于list，第2页及更多的信息通过数据库的形式加载
</code></pre>
<h3 id="set类型">set类型</h3>
<ul>
<li>
<p>新的存储需求：存储大量的数据，在<strong>查询</strong>方面提供更高的效率</p>
</li>
<li>
<p>需要的存储结构：能够保存大量的数据，<strong>高效</strong>的内部存储机制，便于查询</p>
</li>
<li>
<p>set类型：与<strong>hash</strong>存储结构完全相同，仅存储键，不存储值（nil），并且值是不允许重复的</p>
</li>
</ul>
<figure data-type="image" tabindex="2"><img src="https://rexshi96.github.io/post-images/1594434442551.png" alt="" loading="lazy"></figure>
<p>Tips 8：</p>
<p>​		 redis 应用于随机推荐类信息检索，例如热点歌单推荐，热点新闻推荐，热卖旅游线路，应用APP推荐，<br>
大V推荐等</p>
<p>Tips 9：</p>
<ul>
<li>
<p>redis 应用于同类信息的关联搜索，二度关联搜索，深度关联搜索</p>
</li>
<li>
<p>显示共同关注（一度）</p>
</li>
<li>
<p>显示共同好友（一度）</p>
</li>
<li>
<p>由用户A出发，获取到好友用户B的好友信息列表（一度）</p>
</li>
<li>
<p>由用户A出发，获取到好友用户B的购物清单列表（二度）</p>
</li>
<li>
<p>由用户A出发，获取到好友用户B的游戏充值列表（二度）</p>
</li>
<li></li>
</ul>
<p>set类型数据操作的注意事项：</p>
<ol>
<li>set类型不允许重复，如果添加的数据在set中已经存在，只保留一份。</li>
<li>set虽然与hash存储结构相同，但是无法启用hash中存储值的空间</li>
</ol>
<p>Tips 11：</p>
<ul>
<li>redis 应用于同类型数据的快速去重</li>
</ul>
<p>Tips 12：</p>
<ul>
<li>redis 应用于基于黑名单与白名单设定的服务控制</li>
</ul>
<h3 id="sorted_set-类型">sorted_set 类型</h3>
<p>​	在set存储结构的基础上添加可排序字段</p>
<p>Tips 13：</p>
<ul>
<li>redis 应用于计数器组合排序功能对应的排名</li>
</ul>
<p>sorted_set类型数据操作的注意事项：</p>
<ul>
<li>score保存的数据空间是64位，如果是整数范围是-9007199254740992~9007199254740992</li>
<li>score保存的数据也可以是一个双精度的double值，基于双精度浮点数的特征，可能会丢失精度，使用时要慎重</li>
<li>sorted_set底层存储还是基于set结构的，因此数据不能重复，如果重复添加，score值将会被覆盖，保存最后一次修改的结果</li>
</ul>
<p>Tips 14：</p>
<ul>
<li>redis 应用于定时任务执行顺序管理或任务过期管理</li>
</ul>
<p>Tips 15：</p>
<ul>
<li>redis 应用于即时任务/消息队列执行管理</li>
</ul>
<p>Tips 16：</p>
<ul>
<li>redis 应用于限时按次结算的服务控制</li>
</ul>
<p>Tips 17：</p>
<ul>
<li>redis 应用于基于时间顺序的数据操作，而不关注具体时间</li>
</ul>
<h2 id="3持久化">3.持久化</h2>
<h3 id="31-rdb">3.1 RDB</h3>
<p><strong>save</strong>指令的执行会<strong>阻塞</strong>当前Redis服务器，直到当前RDB过程完成为止，有可能会造成长时间阻塞，线上环境不建议使用</p>
<p><strong>bgsave</strong>指令：</p>
<p>​	手动启动后台保存操作，但不是立即执行</p>
<figure data-type="image" tabindex="3"><img src="https://rexshi96.github.io/post-images/1594441208494.png" alt="" loading="lazy"></figure>
<p><strong>注意</strong>： bgsave命令是针对save阻塞问题做的优化。Redis内部所有涉及到RDB操作都采用bgsave的方式，save命令可以放弃使用。</p>
<p><strong>注意</strong>： save配置要根据实际业务情况进行设置，频度过高或过低都会出现性能问题，结果可能是灾难性的save配置中对于second与changes设置通常具有互补对应关系，尽量不要设置成包含性关系save配置启动后执行的是bgsave操作</p>
<p><strong>RDB优点：</strong></p>
<ul>
<li>RDB是一个紧凑压缩的二进制文件，存储效率较高</li>
<li>RDB内部存储的是redis在某个时间点的数据快照，非常适合用于数据备份，全量复制等场景</li>
<li>RDB恢复数据的速度要比AOF快很多</li>
<li>应用：服务器中每X小时执行bgsave备份，并将RDB文件拷贝到远程机器中，用于灾难恢复</li>
</ul>
<p><strong>RDB缺点：</strong></p>
<ul>
<li>RDB方式无论是执行命令还是利用配置，无法做到实时持久化，具有较大丢失数据的可能</li>
<li>大数据量时IO性能低</li>
<li>bgsave指令每次运行要执行fork操作创建子进程，要牺牲一些性能</li>
<li>redis的众多版本中未进行RDB文件格式的版本统一，有可能出现各版本服务之间数据格式无法兼容现象</li>
</ul>
<h3 id="32-aof">3.2 AOF</h3>
<p>以独立日志的方式记录每次写命令，重启时再重新执行AOF文件中的命令恢复数据。与RDB相比可以认为时把记录数据变为记录数据产生的过程；</p>
<p>AOF的主要作用是保证了数据持久化的<strong>实时性</strong>。</p>
<p>AOF写数据的三种策略：</p>
<p>always：</p>
<p>​	每次写入操作，数据零误差，<strong>性能较差</strong>；</p>
<p>everysec：<strong>默认策略</strong></p>
<p>​	每秒写入操作，每秒将缓冲区中的指令同步到AOF文件中，数据准确性较高，性能较高在系统突然宕机的情况下丢失1秒内的数据</p>
<p>no：</p>
<p>​	由系统控制写入的周期，过程<strong>不可控</strong></p>
<p>AOF重写：</p>
<p>​		随着命令不断写入AOF，文件会越来越大，为了解决这个问题，Redis引入了AOF重写机制压缩文件体积AOF文件重写是将Redis进程内的数据转化为写命令同步到新AOF文件的过程。简单说就是将对<strong>同一个数据</strong>的若干个条命令执行结果转化成<strong>最终结果数据</strong>对应的指令进行记录。</p>
<p>AOF重写的作用：</p>
<ul>
<li>降低磁盘占用量，提高磁盘利用率</li>
<li>提高持久化效率，降低持久化写时间，提高IO性能</li>
<li>降低数据恢复用时，提高数据恢复效率</li>
</ul>
<p>AOF重写规则：</p>
<ul>
<li>进程内已超时的数据不再写入文件</li>
<li>忽略无效命令，重写时使用进程内数据直接生成，只保留最终数据的写入命令</li>
<li>对同一数据的多条写命令合并为一条命令，为防止数据量过大造成客户端缓存区溢出，对list，set，hash，zset等类型，每条指令最多写入64个元素</li>
</ul>
<p>AOF重写方式</p>
<p>手动重写：<code>bgrewriteaof</code></p>
<p>自动重写：<code>auto-aof-rewrite-min-size</code></p>
<h3 id="33-rdb与aof的区别">3.3 RDB与AOF的区别</h3>
<table>
<thead>
<tr>
<th>持久化方式</th>
<th>RDB</th>
<th>AOF</th>
</tr>
</thead>
<tbody>
<tr>
<td>占用磁盘空间</td>
<td>小（压缩）</td>
<td>大（命令）</td>
</tr>
<tr>
<td>存储速度</td>
<td>慢</td>
<td>快</td>
</tr>
<tr>
<td>恢复速度</td>
<td>快</td>
<td>慢</td>
</tr>
<tr>
<td>数据安全性</td>
<td>会丢失数据</td>
<td>依策略决定</td>
</tr>
<tr>
<td>资源消耗</td>
<td>高/重量级</td>
<td>低/轻量级</td>
</tr>
<tr>
<td>启动优先级</td>
<td>低</td>
<td>高</td>
</tr>
</tbody>
</table>
<h3 id="34-rdb与aof的选择">3.4 RDB与AOF的选择</h3>
<ul>
<li>对业务数据非常敏感，选用AOF</li>
<li>能够接收数据丢失，追求大数据集的恢复速度，选用RDB</li>
<li>灾难恢复选用RDB</li>
<li>双保险策略，重启优先使用AOF来恢复，降低数据量丢失</li>
</ul>
<h3 id="35-持久化使用场景">3.5 持久化使用场景</h3>
<ul>
<li>Tips 5：redis 应用于抢购，限购类、限量发放优惠卷、激活码等业务的数据存储设计</li>
<li>Tips 6：redis 应用于具有操作先后顺序的数据控制</li>
<li>Tips 7：redis 应用于最新消息展示</li>
<li>Tips 12：redis 应用于基于黑名单与白名单设定的服务控制</li>
<li>Tips 13：redis 应用于计数器组合排序功能对应的排名</li>
</ul>

              </div>
              <div class="toc-container">
                <ul class="markdownIt-TOC">
<li><a href="#redis">Redis</a>
<ul>
<li><a href="#1%E7%AE%80%E4%BB%8B">1.简介</a></li>
<li><a href="#2%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B">2.数据类型</a>
<ul>
<li><a href="#string%E7%B1%BB%E5%9E%8B">string类型</a></li>
<li><a href="#hash%E7%B1%BB%E5%9E%8B">hash类型</a></li>
<li><a href="#list%E7%B1%BB%E5%9E%8B">list类型</a></li>
<li><a href="#set%E7%B1%BB%E5%9E%8B">set类型</a></li>
<li><a href="#sorted_set-%E7%B1%BB%E5%9E%8B">sorted_set 类型</a></li>
</ul>
</li>
<li><a href="#3%E6%8C%81%E4%B9%85%E5%8C%96">3.持久化</a>
<ul>
<li><a href="#31-rdb">3.1 RDB</a></li>
<li><a href="#32-aof">3.2 AOF</a></li>
<li><a href="#33-rdb%E4%B8%8Eaof%E7%9A%84%E5%8C%BA%E5%88%AB">3.3 RDB与AOF的区别</a></li>
<li><a href="#34-rdb%E4%B8%8Eaof%E7%9A%84%E9%80%89%E6%8B%A9">3.4 RDB与AOF的选择</a></li>
<li><a href="#35-%E6%8C%81%E4%B9%85%E5%8C%96%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF">3.5 持久化使用场景</a></li>
</ul>
</li>
</ul>
</li>
</ul>

              </div>
            </div>
          </article>
        </div>

        

        

        <div class="site-footer">
  
  <a class="rss" href="https://rexshi96.github.io/atom.xml" target="_blank">
    <i class="ri-rss-line"></i> RSS
  </a>
</div>

      </div>
    </div>

    <script>
      hljs.initHighlightingOnLoad()

      let mainNavLinks = document.querySelectorAll(".markdownIt-TOC a");

      // This should probably be throttled.
      // Especially because it triggers during smooth scrolling.
      // https://lodash.com/docs/4.17.10#throttle
      // You could do like...
      // window.addEventListener("scroll", () => {
      //    _.throttle(doThatStuff, 100);
      // });
      // Only not doing it here to keep this Pen dependency-free.

      window.addEventListener("scroll", event => {
        let fromTop = window.scrollY;

        mainNavLinks.forEach((link, index) => {
          let section = document.getElementById(decodeURI(link.hash).substring(1));
          let nextSection = null
          if (mainNavLinks[index + 1]) {
            nextSection = document.getElementById(decodeURI(mainNavLinks[index + 1].hash).substring(1));
          }
          if (section.offsetTop <= fromTop) {
            if (nextSection) {
              if (nextSection.offsetTop > fromTop) {
                link.classList.add("current");
              } else {
                link.classList.remove("current");    
              }
            } else {
              link.classList.add("current");
            }
          } else {
            link.classList.remove("current");
          }
        });
      });

    </script>
  </body>
</html>
